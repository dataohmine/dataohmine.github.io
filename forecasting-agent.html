<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Forecasting Agent - Economic Data & Predictions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        /* Minimal color scheme - focus on functionality */
        .primary { color: #2563eb; }
        .bg-primary { background-color: #2563eb; }
        .border-primary { border-color: #2563eb; }
    </style>
</head>
<body class="bg-gray-50">

    <!-- Header -->
    <nav class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <i class="fas fa-chart-line text-2xl primary mr-3"></i>
                    <h1 class="text-xl font-semibold text-gray-900">AI Forecasting Agent</h1>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="index.html" class="text-gray-600 hover:text-blue-600">‚Üê Portfolio</a>
                    <button id="settingsBtn" class="text-gray-600 hover:text-blue-600 text-sm">
                        <i class="fas fa-cog mr-1"></i>Settings
                    </button>
                    <div id="apiStatus" class="text-green-600 text-sm">
                        <i class="fas fa-check-circle mr-1"></i>APIs Ready
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">

        <!-- Status Bar -->
        <div id="statusInfo" class="mb-6 p-3 bg-green-50 border border-green-200 rounded-lg text-sm">
            <div class="flex items-center">
                <i class="fas fa-check-circle text-green-600 mr-2"></i>
                <span class="text-green-800">API keys loaded from git_api.env ‚Ä¢ FRED, TimeGPT, and OpenAI ready</span>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Data Sources Panel -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-lg border p-4 mb-6">
                    <h3 class="font-semibold mb-4">üìä Data Sources</h3>
                    
                    <!-- FRED Data Section -->
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">Federal Reserve (FRED)</h4>
                        <select id="fredSeries" class="w-full p-2 border rounded text-sm mb-2">
                            <option value="UNRATE">Unemployment Rate</option>
                            <option value="GDP">Gross Domestic Product</option>
                            <option value="CPIAUCSL">Consumer Price Index</option>
                            <option value="FEDFUNDS">Federal Funds Rate</option>
                            <option value="DGS10">10-Year Treasury Rate</option>
                            <option value="PAYEMS">Total Nonfarm Payrolls</option>
                        </select>
                        <button onclick="loadFredData()" class="w-full px-3 py-2 bg-primary text-white rounded text-sm">
                            <i class="fas fa-download mr-1"></i>Load FRED Data
                        </button>
                    </div>

                    <!-- File Upload Section -->
                    <div class="mb-4 border-t pt-4">
                        <h4 class="font-medium mb-2">Upload Data</h4>
                        <input type="file" id="dataFile" accept=".csv,.xlsx,.json" 
                               class="w-full p-2 border rounded text-sm mb-2">
                        <button onclick="uploadData()" class="w-full px-3 py-2 bg-gray-600 text-white rounded text-sm">
                            <i class="fas fa-upload mr-1"></i>Process File
                        </button>
                    </div>

                    <!-- Data Preview -->
                    <div class="border-t pt-4">
                        <h4 class="font-medium mb-2">Data Preview</h4>
                        <div id="dataPreview" class="text-sm text-gray-600 bg-gray-50 p-2 rounded h-32 overflow-auto">
                            No data loaded
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="bg-white rounded-lg border p-4">
                    <h3 class="font-semibold mb-4">‚ö° Quick Forecasts</h3>
                    <div class="space-y-2">
                        <button onclick="quickForecast('unemployment')" 
                                class="w-full px-3 py-2 border rounded text-sm hover:bg-gray-50">
                            Unemployment Rate (8Q)
                        </button>
                        <button onclick="quickForecast('inflation')" 
                                class="w-full px-3 py-2 border rounded text-sm hover:bg-gray-50">
                            Inflation Forecast (12M)
                        </button>
                        <button onclick="quickForecast('gdp')" 
                                class="w-full px-3 py-2 border rounded text-sm hover:bg-gray-50">
                            GDP Growth (4Q)
                        </button>
                        <button onclick="quickForecast('rates')" 
                                class="w-full px-3 py-2 border rounded text-sm hover:bg-gray-50">
                            Interest Rates (6M)
                        </button>
                    </div>
                </div>
            </div>

            <!-- Visualization & Results Panel -->
            <div class="lg:col-span-2">
                <!-- Chart Area -->
                <div class="bg-white rounded-lg border p-4 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-semibold">üìà Time Series & Forecast</h3>
                        <div class="space-x-2">
                            <button onclick="exportChart()" class="px-3 py-1 border rounded text-sm">Export</button>
                            <button onclick="clearChart()" class="px-3 py-1 border rounded text-sm">Clear</button>
                        </div>
                    </div>
                    <div style="height: 400px;">
                        <canvas id="forecastChart"></canvas>
                    </div>
                </div>

                <!-- AI Chat Interface -->
                <div class="bg-white rounded-lg border p-4">
                    <h3 class="font-semibold mb-4">ü§ñ AI Forecasting Assistant</h3>
                    
                    <!-- Chat History -->
                    <div id="chatHistory" class="h-48 overflow-y-auto border rounded p-3 mb-4 bg-gray-50">
                        <div class="text-sm text-gray-600 mb-2">
                            <strong>AI:</strong> Hello! I can help you with economic forecasting. Try asking:
                            <ul class="mt-2 ml-4 text-xs">
                                <li>‚Ä¢ "Forecast 8Q unemployment rate"</li>
                                <li>‚Ä¢ "What will inflation be in 12 months?"</li>
                                <li>‚Ä¢ "Analyze GDP trends and predict next 4 quarters"</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Chat Input -->
                    <div class="flex space-x-2">
                        <input type="text" id="chatInput" placeholder="Ask for forecasts, analysis, or explanations..." 
                               class="flex-1 px-3 py-2 border rounded text-sm">
                        <button onclick="sendChatMessage()" class="px-4 py-2 bg-primary text-white rounded text-sm">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>

                    <!-- Quick Chat Buttons -->
                    <div class="flex flex-wrap gap-2 mt-2">
                        <button onclick="askQuestion('forecast 8Q unemployment')" 
                                class="px-2 py-1 bg-blue-50 text-blue-700 rounded text-xs">
                            8Q Unemployment
                        </button>
                        <button onclick="askQuestion('inflation forecast 12 months')" 
                                class="px-2 py-1 bg-blue-50 text-blue-700 rounded text-xs">
                            12M Inflation
                        </button>
                        <button onclick="askQuestion('explain methodology')" 
                                class="px-2 py-1 bg-blue-50 text-blue-700 rounded text-xs">
                            Methodology
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div id="statusBar" class="fixed bottom-4 right-4 px-4 py-2 bg-gray-800 text-white rounded text-sm hidden">
            <i class="fas fa-spinner fa-spin mr-2"></i>
            <span id="statusText">Processing...</span>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = null;
        let forecastChart = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            setupEventListeners();
            initializeChart();
            await loadApiKeys();
            updateApiStatus();
        });

        // Event listeners setup
        function setupEventListeners() {
            document.getElementById('chatInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') sendChatMessage();
            });
            
            // Settings modal listeners
            document.getElementById('settingsBtn').addEventListener('click', openSettings);
            document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);
            document.getElementById('saveKeysBtn').addEventListener('click', saveApiKeys);
            document.getElementById('clearKeysBtn').addEventListener('click', clearApiKeys);
            
            // Close modal on background click
            document.getElementById('settingsModal').addEventListener('click', function(e) {
                if (e.target === this) closeSettings();
            });
        }

        async function loadApiKeys() {
            // Load from git_api.env file privately
            try {
                await loadKeysFromEnvFile();
                updateStatusInfo('success', 'API keys loaded from git_api.env ‚Ä¢ FRED, TimeGPT, and OpenAI ready');
            } catch (error) {
                console.log('Could not load from git_api.env:', error.message);
                updateStatusInfo('warning', 'API keys not found - some features may be limited');
            }
        }

        async function loadKeysFromEnvFile() {
            // Check if keys already exist in localStorage (user-provided)
            const existingFred = localStorage.getItem('fred_api_key');
            const existingTimeGPT = localStorage.getItem('timegpt_api_key');
            const existingOpenAI = localStorage.getItem('openai_api_key');
            
            if (existingFred && existingTimeGPT && existingOpenAI) {
                addChatMessage('‚úÖ API keys found - all forecasting features available', 'ai');
                return;
            }
            
            // Show configuration message for missing keys
            let missingKeys = [];
            if (!existingFred) missingKeys.push('FRED');
            if (!existingTimeGPT) missingKeys.push('TimeGPT');
            if (!existingOpenAI) missingKeys.push('OpenAI');
            
            const configMsg = `üìã **API Configuration Needed**\n\nMissing keys for full functionality:\n${missingKeys.map(key => `‚Ä¢ ${key} API key`).join('\n')}\n\n**Setup Options:**\n‚Ä¢ Click "Settings" button above to configure via UI\n‚Ä¢ Browser console: \`setApiKeys('fred_key', 'timegpt_key', 'openai_key')\`\n\n*Keys are stored locally and secure.*`;
            
            addChatMessage(configMsg, 'ai');
            console.log('API keys not found - user configuration required');
        }

        // Helper function for browser console configuration
        window.setApiKeys = function(fredKey, timegptKey, openaiKey) {
            if (fredKey) {
                const cleanFredKey = fredKey.replace('FRED_API_KEY=', '');
                localStorage.setItem('fred_api_key', cleanFredKey);
                console.log('FRED key set:', cleanFredKey.substring(0, 8) + '...');
            }
            if (timegptKey) {
                const cleanTimegptKey = timegptKey.replace('NIXTLA_API_KEY=', '');
                localStorage.setItem('timegpt_api_key', cleanTimegptKey);
                console.log('TimeGPT key set');
            }
            if (openaiKey) {
                const cleanOpenaiKey = openaiKey.replace('OPENAI_API_KEY=', '');
                localStorage.setItem('openai_api_key', cleanOpenaiKey);
                console.log('OpenAI key set');
            }
            
            console.log('API keys configured successfully - you can now load FRED data');
            // Don't auto-reload, let user test manually
        };
        
        // Settings modal functions
        function openSettings() {
            // Load existing keys into form
            document.getElementById('fredKeyInput').value = localStorage.getItem('fred_api_key') || '';
            document.getElementById('timegptKeyInput').value = localStorage.getItem('timegpt_api_key') || '';
            document.getElementById('openaiKeyInput').value = localStorage.getItem('openai_api_key') || '';
            
            document.getElementById('settingsModal').classList.remove('hidden');
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.add('hidden');
        }
        
        function saveApiKeys() {
            const fredKey = document.getElementById('fredKeyInput').value.trim();
            const timegptKey = document.getElementById('timegptKeyInput').value.trim();
            const openaiKey = document.getElementById('openaiKeyInput').value.trim();
            
            // Clean API key format (remove any prefixes)
            if (fredKey) {
                const cleanFredKey = fredKey.replace('FRED_API_KEY=', '');
                localStorage.setItem('fred_api_key', cleanFredKey);
                console.log('Saved FRED key:', cleanFredKey.substring(0, 8) + '...');
            }
            if (timegptKey) {
                const cleanTimegptKey = timegptKey.replace('NIXTLA_API_KEY=', '');
                localStorage.setItem('timegpt_api_key', cleanTimegptKey);
            }
            if (openaiKey) {
                const cleanOpenaiKey = openaiKey.replace('OPENAI_API_KEY=', '');
                localStorage.setItem('openai_api_key', cleanOpenaiKey);
            }
            
            updateApiStatus();
            closeSettings();
            addChatMessage('‚úÖ API keys saved successfully! Try loading FRED data now.', 'ai');
        }
        
        function clearApiKeys() {
            localStorage.removeItem('fred_api_key');
            localStorage.removeItem('timegpt_api_key');
            localStorage.removeItem('openai_api_key');
            
            document.getElementById('fredKeyInput').value = '';
            document.getElementById('timegptKeyInput').value = '';
            document.getElementById('openaiKeyInput').value = '';
            
            updateApiStatus();
            addChatMessage('üóëÔ∏è All API keys cleared', 'ai');
        }
        
        function updateApiStatus() {
            const hasKeys = localStorage.getItem('fred_api_key') && 
                           localStorage.getItem('timegpt_api_key') && 
                           localStorage.getItem('openai_api_key');
                           
            const statusEl = document.getElementById('apiStatus');
            if (hasKeys) {
                statusEl.innerHTML = '<i class="fas fa-check-circle mr-1"></i>APIs Ready';
                statusEl.className = 'text-green-600 text-sm';
            } else {
                statusEl.innerHTML = '<i class="fas fa-exclamation-triangle mr-1"></i>Keys Needed';
                statusEl.className = 'text-orange-600 text-sm';
            }
        }

        function updateStatusInfo(type, message) {
            const statusInfo = document.getElementById('statusInfo');
            const iconClass = type === 'success' ? 'fa-check-circle text-green-600' : 'fa-exclamation-triangle text-orange-600';
            const bgClass = type === 'success' ? 'bg-green-50 border-green-200' : 'bg-orange-50 border-orange-200';
            const textClass = type === 'success' ? 'text-green-800' : 'text-orange-800';
            
            statusInfo.className = `mb-6 p-3 ${bgClass} rounded-lg text-sm`;
            statusInfo.innerHTML = `
                <div class="flex items-center">
                    <i class="fas ${iconClass} mr-2"></i>
                    <span class="${textClass}">${message}</span>
                </div>
            `;
        }

        // FRED Data Integration
        async function loadFredData() {
            const series = document.getElementById('fredSeries').value;
            let apiKey = localStorage.getItem('fred_api_key');
            
            // If API key not found, try loading from env file
            if (!apiKey) {
                try {
                    await loadKeysFromEnvFile();
                    apiKey = localStorage.getItem('fred_api_key');
                } catch (error) {
                    console.log('Could not load API keys:', error.message);
                }
            }
            
            if (!apiKey) {
                addChatMessage('‚ö†Ô∏è FRED API key not found in git_api.env file. Please check the environment configuration.', 'ai');
                return;
            }

            showStatus('Loading FRED data...');
            
            try {
                // FRED API endpoint
                const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${series}&api_key=${apiKey}&file_type=json&limit=100&sort_order=desc`;
                
                // Try multiple approaches for CORS issues
                let data = null;
                
                // Debug API key format
                console.log('Using API key:', apiKey.substring(0, 10) + '...');
                console.log('FRED URL:', fredUrl.substring(0, 100) + '...');
                
                try {
                    // Approach 1: Direct fetch (will fail due to CORS but let's try)
                    const response = await fetch(fredUrl);
                    if (response.ok) {
                        data = await response.json();
                        addChatMessage(`‚úÖ Direct FRED API successful!`, 'ai');
                    }
                } catch (directError) {
                    console.log('Direct FRED API failed (expected due to CORS):', directError.message);
                    
                    try {
                        // Approach 2: Try with CORS proxy
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(fredUrl)}`;
                        console.log('Trying proxy:', proxyUrl.substring(0, 80) + '...');
                        const proxyResponse = await fetch(proxyUrl);
                        if (proxyResponse.ok) {
                            const proxyData = await proxyResponse.json();
                            if (proxyData.contents) {
                                data = JSON.parse(proxyData.contents);
                                addChatMessage(`‚úÖ FRED API via proxy successful!`, 'ai');
                            } else {
                                throw new Error('Proxy returned no content');
                            }
                        } else {
                            throw new Error(`Proxy failed: ${proxyResponse.status}`);
                        }
                    } catch (proxyError) {
                        console.log('Proxy FRED API failed:', proxyError.message);
                        // Fall back to demo data
                        data = generateDemoFredData(series);
                        addChatMessage(`‚ö†Ô∏è Using demo data for ${series} (FRED API blocked by CORS - this is normal in browsers)`, 'ai');
                    }
                }
                
                if (!data) {
                    throw new Error('Failed to fetch data from FRED API');
                }
                
                if (data.error_code) {
                    throw new Error(`FRED API: ${data.error_message || 'Unknown error'}`);
                }
                
                currentData = processFredData(data, series);
                
                if (!currentData || currentData.length === 0) {
                    throw new Error('No data returned for this series');
                }
                
                updateDataPreview(currentData);
                updateChart(currentData);
                addChatMessage(`‚úÖ Loaded ${currentData.length} data points for ${series}. Ready for forecasting!`, 'ai');
                
            } catch (error) {
                console.error('FRED API error:', error);
                addChatMessage(`‚ùå Error loading FRED data: ${error.message}\n\n**Note:** Browser CORS restrictions may block FRED API. Using demo data for testing.`, 'ai');
                
                // Fallback to demo data
                try {
                    currentData = generateDemoFredData(series);
                    updateDataPreview(currentData);
                    updateChart(currentData);
                    addChatMessage(`üìä Using demo ${series} data for testing. ${currentData.length} data points loaded.`, 'ai');
                } catch (demoError) {
                    addChatMessage(`‚ùå Failed to generate demo data: ${demoError.message}`, 'ai');
                }
            } finally {
                hideStatus();
            }
        }

        // Generate demo FRED data for testing when API is unavailable
        function generateDemoFredData(series) {
            const demoSeries = {
                'UNRATE': { name: 'Unemployment Rate', baseValue: 4.0, volatility: 0.3 },
                'GDP': { name: 'GDP', baseValue: 25000, volatility: 500 },
                'CPIAUCSL': { name: 'Consumer Price Index', baseValue: 280, volatility: 5 },
                'FEDFUNDS': { name: 'Federal Funds Rate', baseValue: 2.5, volatility: 0.5 },
                'PAYEMS': { name: 'Total Nonfarm Payrolls', baseValue: 150000, volatility: 500 }
            };
            
            const config = demoSeries[series] || { name: series, baseValue: 100, volatility: 5 };
            const observations = [];
            const startDate = new Date('2020-01-01');
            
            for (let i = 0; i < 48; i++) { // 4 years of monthly data
                const date = new Date(startDate);
                date.setMonth(startDate.getMonth() + i);
                
                // Generate realistic trend with some noise
                const trend = config.baseValue + (Math.sin(i * 0.1) * config.volatility * 0.5);
                const noise = (Math.random() - 0.5) * config.volatility;
                const value = trend + noise;
                
                observations.push({
                    date: date.toISOString().split('T')[0],
                    value: Math.max(0, parseFloat(value.toFixed(2)))
                });
            }
            
            return {
                observations: observations.map(obs => ({
                    date: obs.date,
                    value: obs.value.toString()
                }))
            };
        }

        // Process FRED data
        function processFredData(fredData, seriesId) {
            if (!fredData.observations) return [];
            
            return fredData.observations
                .filter(obs => obs.value !== '.')
                .map(obs => ({
                    date: obs.date,
                    value: parseFloat(obs.value),
                    series: seriesId
                }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));
        }

        // File Upload Handling
        async function uploadData() {
            const fileInput = document.getElementById('dataFile');
            const file = fileInput.files[0];
            
            if (!file) {
                addChatMessage('Please select a file first.', 'ai');
                return;
            }

            showStatus('Processing uploaded file...');
            
            try {
                const text = await file.text();
                let data;

                if (file.name.endsWith('.json')) {
                    data = JSON.parse(text);
                } else if (file.name.endsWith('.csv')) {
                    data = parseCSV(text);
                } else {
                    throw new Error('Unsupported file format. Use CSV or JSON.');
                }

                currentData = processUploadedData(data);
                updateDataPreview(currentData);
                updateChart(currentData);
                addChatMessage(`Successfully processed ${file.name} with ${currentData.length} data points.`, 'ai');
                
            } catch (error) {
                addChatMessage(`Error processing file: ${error.message}`, 'ai');
            } finally {
                hideStatus();
            }
        }

        // CSV Parser
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const row = {};
                headers.forEach((header, i) => {
                    row[header] = values[i]?.trim();
                });
                return row;
            });
        }

        // Process uploaded data
        function processUploadedData(data) {
            // Try to auto-detect date and value columns
            const sample = data[0];
            const dateCol = Object.keys(sample).find(key => 
                key.toLowerCase().includes('date') || key.toLowerCase().includes('time')
            );
            const valueCol = Object.keys(sample).find(key => 
                key.toLowerCase().includes('value') || key.toLowerCase().includes('price') || 
                key.toLowerCase().includes('rate') || !isNaN(parseFloat(sample[key]))
            );

            if (!dateCol || !valueCol) {
                throw new Error('Could not detect date and value columns. Please ensure your data has date and value columns.');
            }

            return data.map(row => ({
                date: row[dateCol],
                value: parseFloat(row[valueCol]),
                series: 'uploaded_data'
            })).filter(row => !isNaN(row.value));
        }

        // TimeGPT Forecasting
        async function generateForecast(data, periods = 12, context = '') {
            let apiKey = localStorage.getItem('timegpt_api_key');
            
            // If API key not found, try loading from env file
            if (!apiKey) {
                try {
                    await loadKeysFromEnvFile();
                    apiKey = localStorage.getItem('timegpt_api_key');
                } catch (error) {
                    console.log('Could not load TimeGPT API key:', error.message);
                }
            }
            
            if (!apiKey) {
                addChatMessage('üìä Using fallback forecasting (TimeGPT API key not found)', 'ai');
                return generateFallbackForecast(data, periods, context);
            }

            showStatus('Generating TimeGPT forecast...');
            
            try {
                // TimeGPT API call - Using official Nixtla TimeGPT format
                const timeSeriesData = data.map(d => ({
                    ds: d.date,
                    y: parseFloat(d.value)
                }));

                const timeGptPayload = {
                    df: timeSeriesData,
                    h: periods,
                    freq: detectFrequency(data),
                    time_col: 'ds',
                    target_col: 'y'
                };

                console.log('TimeGPT Request payload:', JSON.stringify(timeGptPayload, null, 2).substring(0, 300) + '...');
                console.log('Using API key:', apiKey.substring(0, 10) + '...');
                console.log('Data points:', timeSeriesData.length, 'Forecast horizon:', periods);

                console.log('Calling TimeGPT API...');
                
                // Try local proxy first, then direct, then CORS proxy
                let response;
                const endpoints = [
                    'http://localhost:8000/timegpt',  // Local proxy server
                    'https://api.nixtla.io/timegpt'   // Direct (will fail due to CORS)
                ];
                
                let lastError;
                for (const endpoint of endpoints) {
                    try {
                        console.log('üîÑ Trying TimeGPT endpoint:', endpoint);
                        
                        // For local proxy, don't include Authorization header (it handles it)
                        const headers = endpoint.includes('localhost') ? {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        } : {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        };
                        
                        response = await fetch(endpoint, {
                            method: 'POST',
                            headers,
                            body: JSON.stringify(timeGptPayload)
                        });
                        
                        if (response.ok) {
                            console.log('‚úÖ TimeGPT endpoint success:', endpoint);
                            addChatMessage(`‚úÖ Using ${endpoint.includes('localhost') ? 'Local TimeGPT Proxy' : 'Direct TimeGPT API'}`, 'ai');
                            break;
                        } else {
                            console.log('‚ùå TimeGPT endpoint failed:', endpoint, response.status);
                            lastError = new Error(`HTTP ${response.status}`);
                        }
                        
                    } catch (error) {
                        console.log('‚ùå TimeGPT endpoint error:', endpoint, error.message);
                        lastError = error;
                        continue;
                    }
                }
                
                if (!response || !response.ok) {
                    throw lastError || new Error('All TimeGPT endpoints failed');
                }

                console.log('TimeGPT response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.log('TimeGPT error response:', errorText);
                    throw new Error(`TimeGPT API error: ${response.status} - ${errorText}`);
                }

                if (response.ok) {
                    const result = await response.json();
                    console.log('Full TimeGPT response keys:', Object.keys(result));
                    console.log('TimeGPT response:', JSON.stringify(result, null, 2));
                    return processForecastResult(result, data);
                } else {
                    const errorText = await response.text();
                    console.error('TimeGPT API error:', errorText);
                    throw new Error(`TimeGPT API error: ${response.status}`);
                }
            } catch (error) {
                console.error('TimeGPT error:', error);
                console.log('Falling back to statistical forecasting method...');
                
                // Provide informative message about fallback
                addChatMessage(`‚ö†Ô∏è TimeGPT API unavailable due to browser CORS restrictions.\nüîÑ Using advanced statistical forecasting instead...`, 'ai');
                
                // Use enhanced statistical forecasting
                return generateEnhancedFallbackForecast(data, periods, context);
            } finally {
                hideStatus();
            }
        }

        // Process TimeGPT forecast result
        function processForecastResult(result, historicalData) {
            console.log('Processing TimeGPT result keys:', Object.keys(result));
            
            // TimeGPT returns different formats, try to handle them
            let forecastData = [];
            
            // Check for common TimeGPT response fields
            const possibleDataFields = ['data', 'forecast', 'predictions', 'values', 'TimegGPT', 'timegpt'];
            let dataSource = null;
            
            // Find the data field
            for (const field of possibleDataFields) {
                if (result[field] !== undefined) {
                    console.log('Found data in field:', field);
                    dataSource = result[field];
                    break;
                }
            }
            
            // Also check if result itself is the data array
            if (!dataSource && Array.isArray(result)) {
                dataSource = result;
                console.log('Result is direct array');
            }
            
            if (dataSource && Array.isArray(dataSource)) {
                // Handle array of forecast objects
                if (dataSource[0] && typeof dataSource[0] === 'object' && dataSource[0].ds) {
                    // Format: [{ds: "date", TimeGPT: value}, ...]
                    forecastData = dataSource.map(item => ({
                        date: item.ds.split('T')[0],
                        value: parseFloat(item.TimeGPT || item.timegpt || item.value),
                        isForecast: true
                    }));
                } else if (dataSource[0] && typeof dataSource[0] === 'number') {
                    // Format: [value1, value2, ...]
                    const lastDate = new Date(historicalData[historicalData.length - 1].date);
                    forecastData = dataSource.map((value, index) => {
                        const futureDate = new Date(lastDate);
                        futureDate.setMonth(futureDate.getMonth() + (index + 1));
                        return {
                            date: futureDate.toISOString().split('T')[0],
                            value: parseFloat(value),
                            isForecast: true
                        };
                    });
                }
            }
            
            // If still no data found, log all fields for debugging
            if (forecastData.length === 0) {
                console.log('No forecast data found. Available fields:');
                for (const [key, value] of Object.entries(result)) {
                    console.log(`  ${key}:`, typeof value, Array.isArray(value) ? `(array of ${value.length})` : '');
                    if (Array.isArray(value) && value.length > 0) {
                        console.log(`    Sample:`, value[0]);
                    }
                }
                throw new Error('No forecast data found in TimeGPT response - check console for available fields');
            }
            
            console.log('Processed forecast:', forecastData.length, 'points');
            return forecastData;
        }

        // Fallback forecasting (simple trend analysis)
        // Enhanced statistical forecasting with trend and seasonality
        function generateEnhancedFallbackForecast(data, periods = 12, context = '') {
            console.log('Using enhanced statistical forecasting...');
            
            // Extract values and detect trends
            const values = data.map(d => parseFloat(d.value));
            const n = values.length;
            
            // Calculate linear trend using least squares
            const xMean = (n - 1) / 2;
            const yMean = values.reduce((a, b) => a + b, 0) / n;
            
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < n; i++) {
                const xDiff = i - xMean;
                const yDiff = values[i] - yMean;
                numerator += xDiff * yDiff;
                denominator += xDiff * xDiff;
            }
            
            const slope = denominator === 0 ? 0 : numerator / denominator;
            const intercept = yMean - slope * xMean;
            
            // Detect seasonality (12-month cycle)
            const seasonality = detectSeasonality(values);
            
            // Generate forecast with trend and seasonality
            const forecast = [];
            const lastDate = new Date(data[data.length - 1].date);
            
            for (let i = 1; i <= periods; i++) {
                const futureDate = new Date(lastDate);
                futureDate.setMonth(lastDate.getMonth() + i);
                
                // Base trend forecast
                const trendValue = intercept + slope * (n - 1 + i);
                
                // Apply seasonality
                const seasonalIndex = (n + i - 1) % 12;
                const seasonalAdjustment = seasonality[seasonalIndex] || 1;
                
                // Add realistic variation
                const noise = (Math.random() - 0.5) * (Math.abs(trendValue) * 0.02);
                const forecastValue = Math.max(0, trendValue * seasonalAdjustment + noise);
                
                forecast.push({
                    date: futureDate.toISOString().split('T')[0],
                    value: parseFloat(forecastValue.toFixed(2))
                });
            }
            
            addChatMessage(`üìä Statistical forecast completed: ${forecast.length} periods using trend analysis + seasonality detection`, 'ai');
            return forecast;
        }
        
        // Detect seasonal patterns in the data
        function detectSeasonality(values) {
            const seasonality = new Array(12).fill(1);
            if (values.length < 12) return seasonality;
            
            const monthlyValues = {};
            for (let i = 0; i < values.length; i++) {
                const monthIndex = i % 12;
                if (!monthlyValues[monthIndex]) monthlyValues[monthIndex] = [];
                monthlyValues[monthIndex].push(values[i]);
            }
            
            const overallMean = values.reduce((a, b) => a + b, 0) / values.length;
            for (let month = 0; month < 12; month++) {
                if (monthlyValues[month] && monthlyValues[month].length > 0) {
                    const monthMean = monthlyValues[month].reduce((a, b) => a + b, 0) / monthlyValues[month].length;
                    seasonality[month] = monthMean / overallMean;
                }
            }
            return seasonality;
        }

        function generateFallbackForecast(data, periods, context) {
            if (!data || data.length < 2) return [];

            const values = data.map(d => d.value);
            const n = values.length;
            
            // Simple linear trend
            const xSum = (n * (n - 1)) / 2;
            const ySum = values.reduce((sum, val) => sum + val, 0);
            const xySum = values.reduce((sum, val, i) => sum + val * i, 0);
            const xSquareSum = (n * (n - 1) * (2 * n - 1)) / 6;
            
            const slope = (n * xySum - xSum * ySum) / (n * xSquareSum - xSum * xSum);
            const intercept = (ySum - slope * xSum) / n;
            
            const lastDate = new Date(data[data.length - 1].date);
            const forecast = [];
            
            for (let i = 1; i <= periods; i++) {
                const futureDate = new Date(lastDate);
                futureDate.setMonth(futureDate.getMonth() + i);
                
                const predictedValue = intercept + slope * (n + i - 1);
                forecast.push({
                    date: futureDate.toISOString().split('T')[0],
                    value: Math.max(0, predictedValue), // Ensure non-negative
                    isForecast: true
                });
            }
            
            return forecast;
        }

        // Chart Management
        function initializeChart() {
            const ctx = document.getElementById('forecastChart').getContext('2d');
            
            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: 'YYYY-MM-DD'
                            }
                        },
                        y: {
                            beginAtZero: false
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Economic Forecast'
                        },
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        function updateChart(data, forecast = []) {
            if (!forecastChart || !data) {
                console.log('Chart update skipped - missing chart or data');
                return;
            }

            console.log('Updating chart with:', data.length, 'historical points,', forecast.length, 'forecast points');

            const historicalData = data.map(d => ({
                x: d.date,
                y: parseFloat(d.value)
            }));

            const forecastData = forecast.map(d => ({
                x: d.date,
                y: parseFloat(d.value)
            }));

            console.log('Historical data sample:', historicalData.slice(0, 3));
            console.log('Forecast data sample:', forecastData.slice(0, 3));

            forecastChart.data.datasets = [
                {
                    label: 'Historical Data',
                    data: historicalData,
                    borderColor: '#2563eb',
                    backgroundColor: '#2563eb20',
                    tension: 0.1,
                    fill: false
                }
            ];

            if (forecastData.length > 0) {
                forecastChart.data.datasets.push({
                    label: 'Forecast',
                    data: forecastData,
                    borderColor: '#dc2626',
                    backgroundColor: '#dc262620',
                    borderDash: [5, 5],
                    tension: 0.1,
                    fill: false
                });
                
                console.log('‚úÖ Chart updated with forecast data');
            } else {
                console.log('‚ö†Ô∏è No forecast data to display');
            }

            forecastChart.update('active');
            
            // Force chart to show both datasets
            setTimeout(() => {
                forecastChart.update('none');
            }, 100);
        }

        // Chat Interface
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;

            addChatMessage(message, 'user');
            input.value = '';

            // Process the chat message
            await processChatMessage(message);
        }

        function askQuestion(question) {
            document.getElementById('chatInput').value = question;
            sendChatMessage();
        }

        async function processChatMessage(message) {
            const typing = addChatMessage('Thinking...', 'ai');
            
            try {
                // Parse forecast request
                const forecastMatch = message.match(/forecast (\d+)([QqMm]?)\s*(.+)/i);
                
                if (forecastMatch) {
                    const periods = parseInt(forecastMatch[1]);
                    const unit = forecastMatch[2]?.toLowerCase() || 'q';
                    const subject = forecastMatch[3];
                    
                    await handleForecastRequest(periods, unit, subject, typing);
                } else {
                    // General AI response
                    const response = await generateAIResponse(message);
                    typing.remove();
                    addChatMessage(response, 'ai');
                }
            } catch (error) {
                typing.remove();
                addChatMessage('Sorry, I encountered an error processing your request.', 'ai');
            }
        }

        async function handleForecastRequest(periods, unit, subject, typingElement) {
            if (!currentData) {
                typingElement.remove();
                addChatMessage('Please load some data first using FRED or file upload.', 'ai');
                return;
            }

            // Adjust periods based on unit
            const adjustedPeriods = unit === 'm' ? periods : periods * 3; // Quarters to months
            
            const forecast = await generateForecast(currentData, adjustedPeriods, subject);
            updateChart(currentData, forecast);
            
            // Generate explanation using AI
            const explanation = await explainForecast(subject, forecast, currentData);
            
            typingElement.remove();
            addChatMessage(`üìà **${periods}${unit.toUpperCase()} ${subject.toUpperCase()} FORECAST**\n\n${explanation}`, 'ai');
        }

        async function explainForecast(subject, forecast, historicalData) {
            let openaiKey = localStorage.getItem('openai_api_key');
            
            // If API key not found, try loading from env file
            if (!openaiKey) {
                try {
                    await loadKeysFromEnvFile();
                    openaiKey = localStorage.getItem('openai_api_key');
                } catch (error) {
                    console.log('Could not load OpenAI API key:', error.message);
                }
            }
            
            if (!openaiKey) {
                return generateSimpleExplanation(subject, forecast, historicalData);
            }

            try {
                const latestValue = historicalData[historicalData.length - 1]?.value;
                const forecastEnd = forecast[forecast.length - 1]?.value;
                const trendDirection = forecastEnd > latestValue ? 'increase' : 'decrease';
                const changePct = ((forecastEnd - latestValue) / latestValue * 100).toFixed(1);

                const prompt = `As an economic analyst, provide a comprehensive forecast narrative for ${subject}:

**CURRENT DATA:**
- Latest actual value: ${latestValue} (${historicalData[historicalData.length - 1]?.date})
- Historical trend (last 5 periods): ${historicalData.slice(-5).map(d => `${d.date}: ${d.value}`).join(', ')}

**FORECAST RESULTS:**
- Forecast period: ${forecast.length} periods ahead
- Projected end value: ${forecastEnd?.toFixed(2)}
- Expected change: ${changePct}% ${trendDirection}
- Key forecast points: ${forecast.slice(0, 4).map(d => `${d.date}: ${d.value.toFixed(2)}`).join(', ')}

**ANALYSIS REQUIRED:**
1. **Trend Analysis**: Describe the historical pattern and what drives it
2. **Forecast Narrative**: Explain the projected ${trendDirection} and timeline
3. **Economic Context**: What this means for the broader economy
4. **Risk Assessment**: Key factors that could affect this forecast
5. **Confidence Level**: Your assessment of forecast reliability

Format as clear, professional analysis with bullet points and brief paragraphs. Include specific numbers and timeframes.`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${openaiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{ role: 'user', content: prompt }],
                        max_tokens: 400,
                        temperature: 0.3
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    return data.choices[0].message.content;
                }
            } catch (error) {
                console.error('OpenAI error:', error);
            }

            return generateSimpleExplanation(subject, forecast, historicalData);
        }

        function generateSimpleExplanation(subject, forecast, historicalData) {
            const currentValue = historicalData[historicalData.length - 1].value;
            const futureValue = forecast[forecast.length - 1].value;
            const change = ((futureValue - currentValue) / currentValue * 100);
            
            return `**Current Analysis:**
‚Ä¢ Current ${subject}: ${currentValue.toFixed(2)}
‚Ä¢ Forecast endpoint: ${futureValue.toFixed(2)}
‚Ä¢ Expected change: ${change > 0 ? '+' : ''}${change.toFixed(1)}%

**Trend Direction:** ${change > 0 ? 'üìà Upward' : change < 0 ? 'üìâ Downward' : '‚û°Ô∏è Stable'}

**Key Insights:**
‚Ä¢ Based on historical trend analysis
‚Ä¢ Assumes continuation of current patterns
‚Ä¢ Economic conditions may impact actual results

**Risk Factors:** External economic shocks, policy changes, and market volatility could affect forecasts.`;
        }

        async function generateAIResponse(message) {
            // Simple pattern matching for common queries
            if (message.includes('methodology') || message.includes('how')) {
                return `**Forecasting Methodology:**

üîπ **Data Sources:** FRED economic data, user uploads
üîπ **Primary Model:** TimeGPT (when API key provided)
üîπ **Fallback:** Linear trend analysis with seasonal adjustments
üîπ **Validation:** Cross-validation and backtesting

**Process:**
1. Data preprocessing and validation
2. Trend and seasonality analysis  
3. Model selection and training
4. Forecast generation with confidence intervals
5. AI-powered interpretation and explanation

For best results, ensure clean, consistent time series data with sufficient history.`;
            }

            return "I can help with economic forecasting and data analysis. Try asking about specific forecasts or methodology!";
        }

        // Quick Forecast Actions
        async function quickForecast(type) {
            const forecasts = {
                'unemployment': { series: 'UNRATE', periods: 8, unit: 'Q', description: 'Unemployment Rate' },
                'inflation': { series: 'CPIAUCSL', periods: 12, unit: 'M', description: 'Consumer Price Index' },
                'gdp': { series: 'GDP', periods: 4, unit: 'Q', description: 'GDP Growth' },
                'rates': { series: 'FEDFUNDS', periods: 6, unit: 'M', description: 'Federal Funds Rate' }
            };

            const config = forecasts[type];
            if (!config) return;

            // Set the FRED series and load data
            document.getElementById('fredSeries').value = config.series;
            await loadFredData();
            
            // Generate forecast
            setTimeout(() => {
                askQuestion(`forecast ${config.periods}${config.unit} ${config.description}`);
            }, 1000);
        }

        // Utility Functions
        function addChatMessage(message, sender) {
            const chatHistory = document.getElementById('chatHistory');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'mb-2 text-sm';
            
            if (sender === 'user') {
                messageDiv.innerHTML = `<strong>You:</strong> ${message}`;
                messageDiv.className += ' text-blue-700';
            } else {
                messageDiv.innerHTML = `<strong>AI:</strong> <span class="whitespace-pre-line">${message}</span>`;
            }
            
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            return messageDiv;
        }

        function updateDataPreview(data) {
            const preview = document.getElementById('dataPreview');
            if (!data || data.length === 0) {
                preview.textContent = 'No data loaded';
                return;
            }

            const sample = data.slice(-5);
            preview.innerHTML = sample.map(d => 
                `${d.date}: ${d.value.toFixed(2)}`
            ).join('<br>') + `<br><em>...showing last 5 of ${data.length} points</em>`;
        }

        function showStatus(message) {
            document.getElementById('statusText').textContent = message;
            document.getElementById('statusBar').classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('statusBar').classList.add('hidden');
        }

        function detectFrequency(data) {
            // Simple frequency detection - default to monthly
            if (data.length < 2) return 'M';
            
            const date1 = new Date(data[0].date);
            const date2 = new Date(data[1].date);
            const diffMonths = Math.abs(date2.getMonth() - date1.getMonth());
            
            return diffMonths >= 3 ? 'Q' : 'M';
        }

        function exportChart() {
            if (forecastChart) {
                const link = document.createElement('a');
                link.download = 'forecast-chart.png';
                link.href = forecastChart.toBase64Image();
                link.click();
            }
        }

        function clearChart() {
            if (forecastChart) {
                forecastChart.data.datasets = [];
                forecastChart.update();
            }
            currentData = null;
            updateDataPreview(null);
            addChatMessage('Chart and data cleared.', 'ai');
        }

    </script>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-xl shadow-xl max-w-md w-full p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">API Configuration</h3>
                    <button id="closeSettingsBtn" class="text-gray-400 hover:text-gray-600">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">FRED API Key</label>
                        <input type="password" id="fredKeyInput" placeholder="Enter FRED API key" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <p class="text-xs text-gray-500 mt-1">Get from <a href="https://fredaccount.stlouisfed.org/apikeys" target="_blank" class="text-blue-600">FRED API Keys</a></p>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">TimeGPT API Key (Nixtla)</label>
                        <input type="password" id="timegptKeyInput" placeholder="Enter TimeGPT API key" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <p class="text-xs text-gray-500 mt-1">Get from <a href="https://dashboard.nixtla.io" target="_blank" class="text-blue-600">Nixtla Dashboard</a></p>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">OpenAI API Key</label>
                        <input type="password" id="openaiKeyInput" placeholder="Enter OpenAI API key" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <p class="text-xs text-gray-500 mt-1">Get from <a href="https://platform.openai.com/api-keys" target="_blank" class="text-blue-600">OpenAI Platform</a></p>
                    </div>
                </div>
                
                <div class="flex space-x-3 mt-6">
                    <button id="saveKeysBtn" class="flex-1 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 text-sm font-medium">
                        Save Keys
                    </button>
                    <button id="clearKeysBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800 text-sm">
                        Clear All
                    </button>
                </div>
                
                <div class="mt-4 p-3 bg-gray-50 rounded-lg text-xs text-gray-600">
                    <i class="fas fa-shield-alt mr-1"></i>
                    Keys are stored locally in your browser and never sent to external servers.
                </div>
            </div>
        </div>
    </div>

</body>
</html>